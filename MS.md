**JS 的数据类型分类和判断**

基础类型: ```null``` ```undefined``` ```boolean``` ```number``` ```string``` ```symbol``` 
对象:     ```Obejct```

```Object.prototype.toString.call()```

**值类型和引用类型**

**原型和原型链定义**

每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。

每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 _proto_ 来访问。

对象可以通过 __proto__ 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链。

**继承写法**

ES5

```js
function Super() {}

Super.prototype.getNumber = function() {
  return 1
}

function Sub() {}

let s = new Sub()

Sub.prototype = Object.create(Super.prototype, {
  constructor: {
    value: Sub,
    enumerable: false,
    writable: true,
    configurable: true
  }
})
```

ES6

```js
class Sub extends Super {}
```

**执行上下文**

全局执行上下文; 函数执行上下文; eval 执行上下文

**this**

`this` 只依赖于调用函数前的对象

```js
function foo() {
	console.log(this.a)
}
var a = 1
foo()

var obj = {
	a: 2,
	foo: foo
}
obj.foo()

// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况

// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
var c = new foo()
c.a = 3
console.log(c.a)

// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new
```

**闭包**

函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包

```js
function A() {
  let a = 1
  function B() {
      console.log(a)
  }
  return B
}
```

**为什么要用事件委托**

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上

```html
<ul id="ul">
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
<script>
    let ul = document.querySelector('##ul')
    ul.addEventListener('click', (event) => {
        console.log(event.target);
    })
</script>
```

事件代理的方式相对于直接给目标注册事件来说，有以下优点:

1. 节省内存

2. 不需要给子节点注销事件

**为什么 Dom 操作慢**

直接操作 DOM 后会使页面出现重绘或回流

**HTTP 有什么缺点**

因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。

**HTTP2 有什么好处**

在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。

**HTTPS 有优缺点**

优点:
1、HTTPS具有更好的加密性能，避免用户信息泄露；
2、HTTPS复杂的传输方式，降低网站被劫持的风险；
3、搜索引擎已经全面支持HTTPS抓取、收录，并且会优先展示HTTPS结果；
4、HTTPS绿锁表示可以提升用户对网站信任程度；
5、可以有效防止山寨、镜像网站等

缺点:
1、繁重的计算和多次交互天然的影响了访问速度
2、网站改用HTTPS以后，由HTTP跳转到HTTPS的方式增加了用户访问耗时
3、HTTPS涉及到的安全算法会消耗 CPU 资源，需要增加服务器资源（https访问过程需要加解密）

**为什么说HTTPS 是安全的， 解释一下加密过程（非对称加密， 密钥交换）**

1. 客户端发送一个随机值，需要的协议和加密方式
2. 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
4. 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。

**TCP 三次握手的过程，为什么是三次**

最少需要3次, 之后可以进行数据的传输

**安全相关（XSS & CSRF）**

**浏览器缓存策略**

**浏览器 Cookie 相关**

1. value: 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识
2. http-only: 不能通过 JS 访问 Cookie，减少 XSS 攻击
3. secure: 只能在协议为 HTTPS 的请求中携带
4. same-site: 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击

**性能优化策略**

1. DNS 预解析
```html
<link rel="dns-prefetch" href="//www.lovchun.com">
```

2. 缓存

强缓存和协商缓存

3. 使用 HTTP / 2.0

4. 预加载

```html
<link rel="preload" href="http://example.com">
```

5. 预渲染

```html
<link rel="prerender" href="http://example.com"> 
```

6. 其他

懒执行, 懒加载

7. CDN

静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie

8. WEBPACK

- 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩
- 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码
- 优化图片，对于小图可以使用 base64 的方式写入文件中
- 按照路由拆分代码，实现按需加载
- 给打包出来的文件名添加哈希，实现浏览器缓存文件

**基础的数据结构和算法(比如快排, 冒泡, 背包问题）**

冒泡:
从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 1 的位置。

快排:
随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。

**事件循环原理**

微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver
宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering

1. 执行同步代码，这属于宏任务
2. 执行栈为空，查询是否有微任务需要执行
3. 执行所有微任务
4. 必要的话渲染 UI
5. 然后开始下一轮 Event loop，执行宏任务中的异步代码

通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中

**一些常用的方法， 比如 debounce, throttle, new, create, bind 的实现**

**promise, 异步的处理**

**输入 URL 到页面展示发生了什么**

1. 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来
2. 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了
3. TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据
4. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件
5. 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错
6. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
7. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。
8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件
9. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
10. 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了
